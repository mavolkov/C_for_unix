//очереди
Команда ipcs - выводит информацию о текущем состоянии IPC операционной системы (у очереди key имеет значение 10 (0x0000000a в шестнадцатеричном виде) и поле msqid имеет значение 0 (как правило))

msgget() - создание очереди, возвращает id очереди, если уже существует возвр. кодом ошибки (отриц. значение)

Созданную программой очередь можно удалить выполнив из командной строки: ipcrm msg <id-number>

IPC_CREAT 0666



msgsnd() -- для передачи
int msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg);

msgsnd() принимает 4 параметра: 
Первый -- дескриптор очереди (таким образом, msgsnd() может обращаться только к существующей очереди). 
Второй -- указатель на сообщение -- это структура, которая хранит собственно сообщение и его тип. 
Описание структуры приводится ниже:
struct message{
    long mtype;        // Тип сообщения
    char mesg [MSGSZ]; // Само сообщение, длиной MSGSZ.
};
Третий -- длина сообщения MSGSZ в байтах. 
Четвертый -- параметр msgflg -- описывает действие, которое производится, если количество байт в очереди 
уже равно максимальному числу (msg_qbytes). Общее число сообщений во всех очередях превышает системное ограничение.



msgrcv() -- для приема
int msgrcv (int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

 Все выше перечисленные поля являются элементами структуры msqid_ds.
   
   Функция msgrcv() принимает (по сравнению с msgsnd()) один
   дополнительный параметр -- msgtyp, определяющий тип принимаемого
   сообщения, который должен указать процесс-источник сообщения.

    Приняты
   будут только те сообщения, для которых совпадают значения параметра
   msgtyp и значение поля mtype структуры message (см. выше). Рассмотрим
   приведенное объяснение на примере recv.c

   Следующие программы содержат код, достаточно четко поясняющий только
   что рассмотренные принципы "общения" между процессами. Программа
   send.c создает очередь и помещает в нее сообщение, а recv.c вынимает
   сообщение из очереди и выводит его на экран.
